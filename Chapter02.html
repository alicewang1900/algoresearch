
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Chapter 02: Sorting and Searching</title>
<link href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism.css" rel="stylesheet"/>
<style>
        body {
            background-color: #eef6ff;
            font-family: Arial, sans-serif;
            padding: 20px;
            max-width: 960px;
            margin: auto;
        }
        h1, h2, h3 {
            color: #003366;
        }
        .code-block {
            background: #f4f4f4;
            padding: 1em;
            border-left: 4px solid #003366;
            overflow-x: auto;
        }
        .note {
            background: #dbeaff;
            padding: 1em;
            border-left: 4px solid #003366;
            margin-bottom: 20px;
        }
        .nav {
            margin-bottom: 30px;
        }
        .nav a {
            color: #003366;
            font-weight: bold;
            margin-right: 20px;
            text-decoration: none;
        }
    </style>

<script>
  MathJax = {
    tex: { inlineMath: [['$', '$'], ['\(', '\)']] },
    svg: { fontCache: 'global' }
  };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>
<body>
<div class="nav">
<a href="index.html">üè† Home</a> <span>| Chapter 02: Sorting and Searching</span>
</div>
<div style="margin-bottom: 20px;">
<strong>Chapters:</strong>
<a href="chapter01.html">01</a> |
  <a href="chapter02.html">02</a> |
  <a href="chapter03.html">03</a> |
  <a href="chapter05.html">05</a>
</div>

<h1>Chapter 02: Sorting and Searching</h1>
<h2>Overview</h2>
<p>This chapter covers how to sort data and search efficiently using binary search.</p>
<h2>Core Techniques</h2>
<ol>
<li><strong>Sorting</strong>: Sort arrays before applying logic like max/min, duplicates, ranges.</li>
<li><strong>Binary Search</strong>: Search efficiently in sorted arrays using two-pointer or mid logic.</li>
</ol>
<h3>Technique 1: Sorting</h3>
<div class="note"><strong>Why:</strong> Sorting enables efficient range handling, duplicate detection, and binary search.</div>
<h4>Example: Sort Integers</h4>
<pre class="code-block"><code class="language-python"># Python
arr = list(map(int, input().split()))
arr.sort()
print(*arr)</code></pre>
<pre class="code-block"><code class="language-cpp">// C++
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

int main() {
    int n; cin &gt;&gt; n;
    vector<int> arr(n);
    for (int &amp;x : arr) cin &gt;&gt; x;
    sort(arr.begin(), arr.end());
    for (int x : arr) cout &lt;&lt; x &lt;&lt; " ";
}</int></code></pre>
<h3>Technique 2: Binary Search</h3>
<div class="note"><strong>Why:</strong> Once sorted, we can search in O(log n) time using binary search for performance.</div>
<h4>Example: Find a Target Value</h4>
<pre class="code-block"><code class="language-python"># Python
arr = list(map(int, input().split()))
target = int(input())
arr.sort()
left, right = 0, len(arr) - 1
found = False
while left &lt;= right:
    mid = (left + right) // 2
    if arr[mid] == target:
        found = True
        break
    elif arr[mid] &lt; target:
        left = mid + 1
    else:
        right = mid - 1
print(found)</code></pre>
<pre class="code-block"><code class="language-cpp">// C++
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int main() {
    int n, x; cin &gt;&gt; n &gt;&gt; x;
    int a[n];
    for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i];
    sort(a, a+n);
    int l = 0, r = n-1, mid;
    bool found = false;
    while (l &lt;= r) {
        mid = (l + r) / 2;
        if (a[mid] == x) { found = true; break; }
        else if (a[mid] &lt; x) l = mid + 1;
        else r = mid - 1;
    }
    cout &lt;&lt; (found ? "YES" : "NO") &lt;&lt; endl;
}</code></pre>
<h2>Common Mistakes</h2>
<ul>
<li><strong>Not sorting before binary search:</strong> Binary search only works on sorted data.</li>
<li><strong>Off-by-one errors:</strong> Midpoint and loop bounds (‚â§ or &lt;) often cause subtle bugs.</li>
<li><strong>Using == when lower_bound needed:</strong> You may want the first value ‚â• x, not necessarily == x.</li>
</ul>
<h2>Summary</h2>
<ul>
<li>Always sort before using binary search.</li>
<li>Use built-in sort if possible.</li>
<li>Binary search = powerful + fast, but logic must be precise.</li>
</ul>
<script src="https://cdn.jsdelivr.net/npm/prismjs/prism.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-python.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-cpp.min.js"></script>
<h2>Error Examples &amp; Fixes</h2>
<h4>Error: Sorting integers as strings</h4>
<pre class="code-block"><code class="language-python"># Wrong
nums = ["10", "2", "1"]
nums.sort()</code></pre>
<p><strong>Fix:</strong> Convert to integers before sorting.</p>
<pre class="code-block"><code class="language-python">nums = list(map(int, nums))
nums.sort()</code></pre>
</body>
</html>
